using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Lithium.SourceGenerators;

[Generator]
public class ToStringGenerator : IIncrementalGenerator
{
    private const string AttributeName = "Lithium.SourceGenerators.Attributes.ToStringIncludeAttribute";
    private const string AttributeSourceCode = @"// <auto-generated/>
namespace Lithium.SourceGenerators.Attributes;

[System.AttributeUsage(System.AttributeTargets.Property)]
internal class ToStringIncludeAttribute : System.Attribute
{
}
";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "ToStringIncludeAttribute.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        var pipeline = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: (node, _) => node is TypeDeclarationSyntax t && t.Modifiers.Any(m => m.ValueText == "partial"),
            transform: (ctx, _) => GetTypeToGenerate(ctx)
        ).Where(c => c is not null);

        context.RegisterSourceOutput(pipeline, (spc, symbol) => Execute(spc, symbol!));
    }

    private static INamedTypeSymbol? GetTypeToGenerate(GeneratorSyntaxContext context)
    {
        var typeDeclaration = (TypeDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(typeDeclaration);

        if (symbol is not INamedTypeSymbol namedSymbol) return null;

        foreach (var member in namedSymbol.GetMembers())
        {
            if (member is IPropertySymbol property &&
                property.GetAttributes().Any(ad => ad.AttributeClass?.ToDisplayString() == AttributeName))
            {
                return namedSymbol;
            }
        }

        return null;
    }

    private static void Execute(SourceProductionContext context, INamedTypeSymbol typeSymbol)
    {
        var ns = typeSymbol.ContainingNamespace;
        var typeName = typeSymbol.Name;

        var props = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.GetAttributes().Any(a => a.AttributeClass?.ToDisplayString() == AttributeName))
            .ToArray();

        if (props.Length == 0)
            return;

        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine();

        if (!ns.IsGlobalNamespace)
        {
            sb.AppendLine($"namespace {ns.ToDisplayString()};");
            sb.AppendLine();
        }

        var keyword = typeSymbol.TypeKind switch
        {
            TypeKind.Struct => typeSymbol.IsRecord ? "record struct" : "struct",
            _ => typeSymbol.IsRecord ? "record" : "class"
        };

        sb.AppendLine($"partial {keyword} {typeName}");
        sb.AppendLine("{");

        sb.Append($"    public override string ToString() => $\"{typeName}(");

        for (int i = 0; i < props.Length; i++)
        {
            if (i > 0) sb.Append(", ");

            var name = props[i].Name;
            sb.Append($"{name}={{{name}}}");
        }

        sb.AppendLine(")\";");

        sb.AppendLine("}");

        context.AddSource($"{typeName}.ToString.g.cs",
            SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}
