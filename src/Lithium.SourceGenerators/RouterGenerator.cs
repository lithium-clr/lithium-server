using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Lithium.SourceGenerators
{
    [Generator]
    public class RouterGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not SyntaxReceiver receiver)
                return;

            var compilation = context.Compilation;
            var attributeSymbol = compilation.GetTypeByMetadataName("Lithium.Server.Core.Protocol.Attributes.RegisterPacketHandlerAttribute");
            if (attributeSymbol == null) return;
            
            var routerClasses = new List<INamedTypeSymbol>();
            var baseRouterSymbol = compilation.GetTypeByMetadataName("Lithium.Server.Core.Protocol.BasePacketRouter");
            if(baseRouterSymbol == null) return;

            // Collect all classes that are concrete implementations of BasePacketRouter
            foreach (var candidateClass in receiver.CandidateClasses)
            {
                var model = compilation.GetSemanticModel(candidateClass.SyntaxTree);
                var classSymbol = model.GetDeclaredSymbol(candidateClass) as INamedTypeSymbol;
                if (classSymbol == null || classSymbol.IsAbstract || classSymbol.IsGenericType) continue; // Skip abstract or generic
                
                // Check if it inherits from BasePacketRouter
                INamedTypeSymbol? currentBaseType = classSymbol.BaseType;
                while (currentBaseType != null)
                {
                    if (SymbolEqualityComparer.Default.Equals(currentBaseType, baseRouterSymbol))
                    {
                        routerClasses.Add(classSymbol);
                        break;
                    }
                    currentBaseType = currentBaseType.BaseType;
                }
            }

            if (!routerClasses.Any()) return;

            var sbInitializer = new StringBuilder();
            var format = SymbolDisplayFormat.FullyQualifiedFormat;

            // Generate RouterInitializer.cs
            sbInitializer.AppendLine("// <auto-generated />");
            sbInitializer.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sbInitializer.AppendLine();
            sbInitializer.AppendLine("namespace Lithium.Server.Core.Protocol");
            sbInitializer.AppendLine("{");
            sbInitializer.AppendLine("    public static class RouterInitializer");
            sbInitializer.AppendLine("    {");
            sbInitializer.AppendLine("        public static void InitializeRouters(System.IServiceProvider sp)");
            sbInitializer.AppendLine("        {");

            foreach(var router in routerClasses)
            {
                sbInitializer.AppendLine($"            sp.GetRequiredService<{router.ToDisplayString(format)}>().Initialize(sp);");
            }
            
            sbInitializer.AppendLine("        }");
            sbInitializer.AppendLine("    }");
            sbInitializer.AppendLine("}");
            context.AddSource("RouterInitializer.Generated.cs", SourceText.From(sbInitializer.ToString(), Encoding.UTF8));


            // Generate Initialize method for each concrete router
            foreach(var router in routerClasses)
            {
                var sbRouter = new StringBuilder();
                var ns = router.ContainingNamespace.ToDisplayString();

                sbRouter.AppendLine("// <auto-generated />");
                sbRouter.AppendLine("using Microsoft.Extensions.DependencyInjection;"); // Needed for GetRequiredService
                sbRouter.AppendLine();
                sbRouter.AppendLine($"namespace {ns}");
                sbRouter.AppendLine("{");
                sbRouter.AppendLine($"    public partial class {router.Name}");
                sbRouter.AppendLine("    {");
                sbRouter.AppendLine($"        public override partial void Initialize(System.IServiceProvider sp)");
                sbRouter.AppendLine("        {");

                var handlersForRouter = compilation.GetSymbolsWithName(_ => true, SymbolFilter.Type)
                    .OfType<INamedTypeSymbol>()
                    .Where(s => s.GetAttributes().Any(ad => {
                        if (!SymbolEqualityComparer.Default.Equals(ad.AttributeClass, attributeSymbol)) return false;
                        if (ad.ConstructorArguments.Length > 0 && ad.ConstructorArguments[0].Value is INamedTypeSymbol typeSymbol) {
                            return SymbolEqualityComparer.Default.Equals(typeSymbol, router);
                        }
                        return false;
                    }));

                foreach (var handler in handlersForRouter)
                {
                    var interfaceType = handler.AllInterfaces.FirstOrDefault(i => i.ToDisplayString().Contains("IPacketHandler") && i.IsGenericType);
                    if (interfaceType != null && interfaceType.TypeArguments.Length > 0)
                    {
                        var packetType = interfaceType.TypeArguments[0];
                        sbRouter.AppendLine($"                Register<{packetType.ToDisplayString(format)}>(sp.GetRequiredService<{handler.ToDisplayString(format)}>());");
                    }
                }

                sbRouter.AppendLine("        }");
                sbRouter.AppendLine("    }");
                sbRouter.AppendLine("}");

                context.AddSource($"{router.Name}.Generated.cs", SourceText.From(sbRouter.ToString(), Encoding.UTF8));
            }
        }

        private class SyntaxReceiver : ISyntaxReceiver
        {
            public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is ClassDeclarationSyntax classDeclarationSyntax)
                {
                    CandidateClasses.Add(classDeclarationSyntax);
                }
            }
        }
    }
}
