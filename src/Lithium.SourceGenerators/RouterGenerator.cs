using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Lithium.SourceGenerators;

[Generator]
public class RouterGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver) return;
        var compilation = context.Compilation;
            
        var attributeSymbol =
            compilation.GetTypeByMetadataName(
                "Lithium.Server.Core.Protocol.Attributes.RegisterPacketHandlerAttribute");
            
        if (attributeSymbol is null) return;

        var routerHandlers =
            new Dictionary<INamedTypeSymbol, List<INamedTypeSymbol>>(SymbolEqualityComparer.Default);

        foreach (var candidateClass in receiver.CandidateClasses)
        {
            var model = compilation.GetSemanticModel(candidateClass.SyntaxTree);
            var classSymbol = model.GetDeclaredSymbol(candidateClass) as INamedTypeSymbol;
                
            var attr = classSymbol?.GetAttributes().FirstOrDefault(ad =>
                SymbolEqualityComparer.Default.Equals(ad.AttributeClass, attributeSymbol));

            if (attr is not { ConstructorArguments.Length: > 0 }) continue;
            if (attr.ConstructorArguments[0].Value is not INamedTypeSymbol routerType) continue;

            if (!routerHandlers.ContainsKey(routerType))
                routerHandlers[routerType] = [];

            routerHandlers[routerType].Add(classSymbol);
        }

        var format = SymbolDisplayFormat.FullyQualifiedFormat;

        foreach (var kvp in routerHandlers)
        {
            var routerType = kvp.Key;
            var handlers = kvp.Value;

            var sb = new StringBuilder();
            var ns = routerType.ContainingNamespace.ToDisplayString();

            sb.AppendLine("// <auto-generated />");
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sb.AppendLine();
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
            sb.AppendLine($"    public partial class {routerType.Name}");
            sb.AppendLine("    {");
            sb.AppendLine("        private void RegisterHandlers(System.IServiceProvider sp)");
            sb.AppendLine("        {");

            foreach (var handler in handlers)
            {
                var interfaceType =
                    handler.AllInterfaces.FirstOrDefault(i => i.Name == "IPacketHandler" && i.IsGenericType);
                if (interfaceType is not { TypeArguments.Length: > 0 }) continue;

                var packetType = interfaceType.TypeArguments[0];
                sb.AppendLine(
                    $"            Register<{packetType.ToDisplayString(format)}>(sp.GetRequiredService<{handler.ToDisplayString(format)}>());");
            }

            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            context.AddSource($"{routerType.Name}.Generated.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
        }
    }

    private class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } = [];

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is ClassDeclarationSyntax { AttributeLists.Count: > 0 } classDeclarationSyntax)
                CandidateClasses.Add(classDeclarationSyntax);
        }
    }
}