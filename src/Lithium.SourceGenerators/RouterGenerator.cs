using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Lithium.SourceGenerators;

[Generator]
public sealed class RouterGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver)
            return;

        var compilation = context.Compilation;
        
        var attributeSymbol =
            compilation.GetTypeByMetadataName(
                "Lithium.Server.Core.Networking.Protocol.Attributes.RegisterPacketHandlerAttribute");
        
        if (attributeSymbol is null) return;

        var routerClasses = new List<INamedTypeSymbol>();
        
        var baseRouterSymbol = compilation.GetTypeByMetadataName("Lithium.Server.Core.Networking.Protocol.BasePacketRouter");
        if (baseRouterSymbol is null) return;

        // Collect all classes that are concrete implementations of BasePacketRouter
        foreach (var candidateClass in receiver.CandidateClasses)
        {
            var model = compilation.GetSemanticModel(candidateClass.SyntaxTree);
            
            if (model.GetDeclaredSymbol(candidateClass) is not INamedTypeSymbol classSymbol ||
                classSymbol.IsAbstract || classSymbol.IsGenericType) continue; // Skip abstract or generic

            // Check if it inherits from BasePacketRouter
            var currentBaseType = classSymbol.BaseType;

            while (currentBaseType is not null)
            {
                if (SymbolEqualityComparer.Default.Equals(currentBaseType, baseRouterSymbol))
                {
                    routerClasses.Add(classSymbol);
                    break;
                }

                currentBaseType = currentBaseType.BaseType;
            }
        }

        if (!routerClasses.Any()) return;

        var sbInitializer = new StringBuilder();
        var format = SymbolDisplayFormat.FullyQualifiedFormat;

        // Generate RouterInitializer.cs
        sbInitializer.AppendLine("// <auto-generated />");
        sbInitializer.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sbInitializer.AppendLine();
        sbInitializer.AppendLine("namespace Lithium.Server.Core.Networking");
        sbInitializer.AppendLine("{");
        sbInitializer.AppendLine("    public static class RouterInitializer");
        sbInitializer.AppendLine("    {");
        sbInitializer.AppendLine("        public static void InitializeRouters(System.IServiceProvider sp)");
        sbInitializer.AppendLine("        {");

        foreach (var router in routerClasses)
        {
            sbInitializer.AppendLine(
                $"            sp.GetRequiredService<{router.ToDisplayString(format)}>().Initialize(sp);");
        }

        sbInitializer.AppendLine("        }");
        sbInitializer.AppendLine("    }");
        sbInitializer.AppendLine("}");
        
        context.AddSource("RouterInitializer.Generated.cs",
            SourceText.From(sbInitializer.ToString(), Encoding.UTF8));

        // Generate Initialize method for each concrete router
        foreach (var router in routerClasses)
        {
            var sbRouter = new StringBuilder();
            var ns = router.ContainingNamespace.ToDisplayString();

            sbRouter.AppendLine("// <auto-generated />");
            sbRouter.AppendLine("using Microsoft.Extensions.DependencyInjection;"); // Needed for GetRequiredService
            sbRouter.AppendLine();
            sbRouter.AppendLine($"namespace {ns}");
            sbRouter.AppendLine("{");
            sbRouter.AppendLine($"    public partial class {router.Name}");
            sbRouter.AppendLine("    {");
            sbRouter.AppendLine($"        public override partial void Initialize(System.IServiceProvider sp)");
            sbRouter.AppendLine("        {");

            var handlersForRouter = compilation.GetSymbolsWithName(_ => true, SymbolFilter.Type)
                .OfType<INamedTypeSymbol>()
                .Where(s => s.GetAttributes().Any(ad =>
                {
                    if (!SymbolEqualityComparer.Default.Equals(ad.AttributeClass, attributeSymbol)) return false;
                    
                    if (ad.ConstructorArguments.Length > 0 &&
                        ad.ConstructorArguments[0].Value is INamedTypeSymbol typeSymbol)
                    {
                        return SymbolEqualityComparer.Default.Equals(typeSymbol, router);
                    }

                    return false;
                }));

            foreach (var handler in handlersForRouter)
            {
                var interfaceType = handler.AllInterfaces.FirstOrDefault(i =>
                    i.ToDisplayString().Contains("IPacketHandler") && i.IsGenericType);

                if (interfaceType is not { TypeArguments.Length: > 0 }) continue;
                
                var packetType = interfaceType.TypeArguments[0];
                sbRouter.AppendLine(
                    $"                Register<{packetType.ToDisplayString(format)}>(sp.GetRequiredService<{handler.ToDisplayString(format)}>());");
            }

            sbRouter.AppendLine("        }");
            sbRouter.AppendLine("    }");
            sbRouter.AppendLine("}");

            context.AddSource($"{router.Name}.Generated.cs", SourceText.From(sbRouter.ToString(), Encoding.UTF8));
        }
    }

    private sealed class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } = [];

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is ClassDeclarationSyntax classDeclarationSyntax)
                CandidateClasses.Add(classDeclarationSyntax);
        }
    }
}