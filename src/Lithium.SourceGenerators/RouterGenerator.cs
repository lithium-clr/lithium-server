using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Lithium.SourceGenerators;

[Generator]
public sealed class RouterGenerator : ISourceGenerator
{
    private const string RegisterHandlerAttr =
        "Lithium.Server.Core.Networking.Protocol.Attributes.RegisterPacketHandlerAttribute";

    private const string PacketHandlerAttr =
        "Lithium.Server.Core.Networking.Protocol.Attributes.PacketHandlerAttribute";

    private const string BaseRouterType = "Lithium.Server.Core.Networking.Protocol.Routers.BasePacketRouter";

    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not SyntaxReceiver receiver) return;

        var compilation = context.Compilation;
        var regAttrSymbol = compilation.GetTypeByMetadataName(RegisterHandlerAttr);
        var packetHandlerAttrSymbol = compilation.GetTypeByMetadataName(PacketHandlerAttr);
        var baseRouterSymbol = compilation.GetTypeByMetadataName(BaseRouterType);

        if (baseRouterSymbol is null) return;

        var routerClasses = new List<INamedTypeSymbol>();
        foreach (var candidateClass in receiver.CandidateClasses)
        {
            var model = compilation.GetSemanticModel(candidateClass.SyntaxTree);
            
            if (model.GetDeclaredSymbol(candidateClass) is not INamedTypeSymbol classSymbol ||
                classSymbol.IsAbstract) continue;

            var currentBaseType = classSymbol.BaseType;
            
            while (currentBaseType is not null)
            {
                if (SymbolEqualityComparer.Default.Equals(currentBaseType, baseRouterSymbol))
                {
                    routerClasses.Add(classSymbol);
                    break;
                }

                currentBaseType = currentBaseType.BaseType;
            }
        }

        if (!routerClasses.Any()) return;

        var format = SymbolDisplayFormat.FullyQualifiedFormat;

        var sbInit = new StringBuilder();
        sbInit.AppendLine(
            "// <auto-generated />\nusing Microsoft.Extensions.DependencyInjection;\nnamespace Lithium.Server.Core.Networking\n{\n    public static class RouterInitializer\n    {\n        public static void InitializeRouters(System.IServiceProvider sp)\n        {");
        foreach (var router in routerClasses)
            sbInit.AppendLine($"            sp.GetRequiredService<{router.ToDisplayString(format)}>().Initialize(sp);");
        sbInit.AppendLine("        }\n    }\n}");
        context.AddSource("RouterInitializer.Generated.cs", SourceText.From(sbInit.ToString(), Encoding.UTF8));

        foreach (var router in routerClasses)
        {
            var sbRouter = new StringBuilder();
            sbRouter.AppendLine("// <auto-generated />");
            sbRouter.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sbRouter.AppendLine(
                $"namespace {router.ContainingNamespace.ToDisplayString()}\n{{\n    public partial class {router.Name}\n    {{\n        public override partial void Initialize(System.IServiceProvider sp)\n        {{");

            var methods = router.GetMembers().OfType<IMethodSymbol>();
            foreach (var method in methods)
            {
                if (method.GetAttributes().Any(ad =>
                        SymbolEqualityComparer.Default.Equals(ad.AttributeClass, packetHandlerAttrSymbol)))
                {
                    if (method.Parameters.Length is 2)
                    {
                        var packetType = method.Parameters[1].Type;
                        sbRouter.AppendLine(
                            $"            RegisterAction<{packetType.ToDisplayString(format)}>({method.Name});");
                    }
                }
            }

            if (regAttrSymbol is not null)
            {
                var externalHandlers = compilation.GetSymbolsWithName(_ => true, SymbolFilter.Type)
                    .OfType<INamedTypeSymbol>()
                    .Where(s => s.GetAttributes().Any(ad =>
                    {
                        if (!SymbolEqualityComparer.Default.Equals(ad.AttributeClass, regAttrSymbol)) return false;
                        return ad.ConstructorArguments.Length > 0 &&
                               SymbolEqualityComparer.Default.Equals(
                                   ad.ConstructorArguments[0].Value as INamedTypeSymbol, router);
                    }));

                foreach (var handler in externalHandlers)
                {
                    var interfaceType = handler.AllInterfaces.FirstOrDefault(i =>
                        i.ToDisplayString().Contains("IPacketHandler") && i.IsGenericType);
                    
                    if (interfaceType is { TypeArguments.Length: > 0 })
                    {
                        var packetType = interfaceType.TypeArguments[0];
                        sbRouter.AppendLine(
                            $"            Register<{packetType.ToDisplayString(format)}>(sp.GetRequiredService<{handler.ToDisplayString(format)}>());");
                    }
                }
            }

            sbRouter.AppendLine("        }\n    }\n}");
            context.AddSource($"{router.Name}.Generated.cs", SourceText.From(sbRouter.ToString(), Encoding.UTF8));
        }
    }

    private sealed class SyntaxReceiver : ISyntaxReceiver
    {
        public List<ClassDeclarationSyntax> CandidateClasses { get; } = [];

        public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
        {
            if (syntaxNode is ClassDeclarationSyntax cds) CandidateClasses.Add(cds);
        }
    }
}